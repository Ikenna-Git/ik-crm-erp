import { NextResponse } from "next/server"
import nodemailer from "nodemailer"
import { prisma } from "@/lib/prisma"
import { getUserFromRequest } from "@/lib/request-user"
import { buildAccountingSummary, buildCrmSummary } from "@/lib/report-builders"
import { formatNaira } from "@/lib/currency"
import { createAuditLog } from "@/lib/audit"

const REQUIRED_ENVS = ["SMTP_HOST", "SMTP_PORT", "SMTP_USER", "SMTP_PASS", "SMTP_FROM"] as const

const dbUnavailable = () =>
  NextResponse.json({ error: "Database not configured. Set DATABASE_URL to enable digest emails." }, { status: 503 })

const startOfMonth = (date: Date) => new Date(date.getFullYear(), date.getMonth(), 1)

const buildDigestPayload = async (orgId: string) => {
  const now = new Date()
  const monthStart = startOfMonth(now)

  const [
    contactsCount,
    openDealsCount,
    pipelineValue,
    revenueMtd,
    expensesMtd,
    overdueInvoices,
    pendingExpenses,
    openTasks,
    accountingSummary,
    crmSummary,
  ] = await Promise.all([
    prisma.contact.count({ where: { orgId } }),
    prisma.deal.count({ where: { orgId, stage: { notIn: ["WON", "LOST"] } } }),
    prisma.deal.aggregate({ where: { orgId, stage: { notIn: ["LOST"] } }, _sum: { value: true } }),
    prisma.invoice.aggregate({
      where: {
        orgId,
        status: "PAID",
        OR: [{ issueDate: { gte: monthStart } }, { issueDate: null, createdAt: { gte: monthStart } }],
      },
      _sum: { amount: true },
    }),
    prisma.expense.aggregate({
      where: {
        orgId,
        OR: [{ date: { gte: monthStart } }, { date: null, createdAt: { gte: monthStart } }],
      },
      _sum: { amount: true },
    }),
    prisma.invoice.count({ where: { orgId, status: "OVERDUE" } }),
    prisma.expense.count({ where: { orgId, status: "PENDING" } }),
    prisma.task.count({ where: { orgId, status: "OPEN", dueDate: { lt: now } } }),
    buildAccountingSummary(orgId),
    buildCrmSummary(orgId),
  ])

  return {
    generatedAt: now,
    stats: {
      contacts: contactsCount,
      openDeals: openDealsCount,
      pipelineValue: pipelineValue._sum.value || 0,
      revenueMtd: revenueMtd._sum.amount || 0,
      expensesMtd: expensesMtd._sum.amount || 0,
      overdueInvoices,
      pendingExpenses,
      openTasks,
    },
    accountingSummary,
    crmSummary,
  }
}

const formatDigestEmail = (payload: Awaited<ReturnType<typeof buildDigestPayload>>) => {
  const { stats, accountingSummary, crmSummary, generatedAt } = payload
  const pipelineSummary = crmSummary?.pipeline?.length
    ? crmSummary.pipeline.map((item: any) => `${item.stage}: ${item.count}`).join(", ")
    : "No pipeline data yet."
  const topDeals = crmSummary?.topDeals?.length
    ? crmSummary.topDeals.map((deal: any) => `• ${deal.title} (${formatNaira(deal.value)})`).join("\n")
    : "• No deals available."

  const lastMonth = accountingSummary?.months?.[accountingSummary.months.length - 1]
  const monthLine = lastMonth
    ? `${lastMonth.month}: ${formatNaira(lastMonth.revenue)} revenue • ${formatNaira(lastMonth.expenses)} expenses`
    : "No accounting data yet."

  return [
    "Civis Executive Digest",
    `Generated: ${generatedAt.toLocaleString()}`,
    "",
    "Headline metrics",
    `- Contacts: ${stats.contacts}`,
    `- Open deals: ${stats.openDeals}`,
    `- Pipeline value: ${formatNaira(stats.pipelineValue)}`,
    `- Revenue (MTD): ${formatNaira(stats.revenueMtd)}`,
    `- Expenses (MTD): ${formatNaira(stats.expensesMtd)}`,
    `- Overdue invoices: ${stats.overdueInvoices}`,
    `- Pending expenses: ${stats.pendingExpenses}`,
    `- Overdue tasks: ${stats.openTasks}`,
    "",
    "CRM snapshot",
    `- Pipeline stages: ${pipelineSummary}`,
    "Top deals:",
    topDeals,
    "",
    "Accounting snapshot",
    `- Latest month: ${monthLine}`,
    "",
    "Generated by Civis Ops Intelligence.",
  ].join("\n")
}

export async function POST(request: Request) {
  if (!process.env.DATABASE_URL) return dbUnavailable()
  try {
    const { org, user } = await getUserFromRequest(request)
    const body = await request.json().catch(() => ({}))
    const { email, sendNow } = body || {}

    const settings = await prisma.userSettings.findUnique({ where: { userId: user.id } })
    if (!settings?.digestEnabled && !sendNow) {
      return NextResponse.json({ error: "Digest is disabled in settings." }, { status: 400 })
    }

    const targetEmail = email || settings?.digestEmail || user.email
    if (!targetEmail) {
      return NextResponse.json({ error: "Email is required to send a digest." }, { status: 400 })
    }

    const missing = REQUIRED_ENVS.filter((key) => !process.env[key])
    if (missing.length) {
      return NextResponse.json({ error: `Missing SMTP configuration: ${missing.join(", ")}` }, { status: 500 })
    }

    const payload = await buildDigestPayload(org.id)
    const message = formatDigestEmail(payload)

    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: Number(process.env.SMTP_PORT || 587),
      secure: Number(process.env.SMTP_PORT || 587) === 465,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    })

    await transporter.sendMail({
      from: process.env.SMTP_FROM,
      to: targetEmail,
      subject: "Civis Executive Digest",
      text: message,
    })

    await prisma.notification.create({
      data: {
        orgId: org.id,
        userId: user.id,
        title: "Executive digest sent",
        message: `Digest delivered to ${targetEmail}.`,
        type: "SUCCESS",
        source: "Reports",
        channel: "email",
      },
    })

    await createAuditLog({
      orgId: org.id,
      userId: user.id,
      action: "Sent executive digest",
      entity: "ReportDigest",
      entityId: org.id,
      metadata: { email: targetEmail },
    })

    return NextResponse.json({ ok: true, message: `Digest sent to ${targetEmail}` })
  } catch (error) {
    console.error("Digest send failed", error)
    return NextResponse.json({ error: "Failed to send digest" }, { status: 500 })
  }
}
